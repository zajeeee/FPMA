import 'dart:io';
import 'dart:typed_data';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:uuid/uuid.dart';
import '../models/fish_product.dart';

class FishProductService {
  static final SupabaseClient _supabase = Supabase.instance.client;
  static const String _bucketName = 'public';
  static const _uuid = Uuid();

  // ===============================
  // üêü Fish Product CRUD Operations
  // ===============================

  /// Create a new fish product with image upload
  static Future<FishProduct?> createFishProduct({
    required String species,
    String? size,
    double? weight,
    String? vesselInfo,
    String? vesselName,
    String? vesselRegistration,
    File? imageFile,
    Uint8List? imageBytes,
    required String inspectorId,
    required String inspectorName,
  }) async {
    try {
      String? imageUrl;
      // Generate unique identifier for image naming (not a QR code)
      String imageId = _generateImageId();

      // 1) Upload image to Supabase Storage if provided
      if (imageFile != null) {
        imageUrl = await _uploadImage(imageFile, imageId);
        if (imageUrl == null) {
          throw Exception('Failed to upload image');
        }
      } else if (imageBytes != null) {
        imageUrl = await _uploadImageBytes(imageBytes, imageId);
        if (imageUrl == null) {
          throw Exception('Failed to upload image');
        }
      }

      // 2) Create fish product record (NO QR CODE at this stage)
      final fishProductData = {
        'species': species,
        'size': size,
        'weight': weight,
        'vessel_info': vesselInfo,
        'vessel_name': vesselName,
        'vessel_registration': vesselRegistration,
        'image_url': imageUrl,
        'qr_code': null, // No QR code generated by Inspector
        'inspector_id': inspectorId,
        'inspector_name': inspectorName,
        'status': 'pending',
        'created_at': DateTime.now().toIso8601String(),
        'updated_at': DateTime.now().toIso8601String(),
      };

      final response =
          await _supabase
              .from('fish_products')
              .insert(fishProductData)
              .select()
              .single();
      final created = FishProduct.fromJson(response);

      // Create an initial inspection entry (pending)
      try {
        final inspection =
            await _supabase
                .from('inspections')
                .insert({
                  'fish_product_id': created.id,
                  'inspector_id': inspectorId,
                  'inspector_name': inspectorName,
                  'status': 'pending',
                  'notes': vesselInfo,
                })
                .select()
                .single();

        // Backfill inspection_id on product
        if (inspection['id'] != null) {
          await _supabase
              .from('fish_products')
              .update({'inspection_id': inspection['id']})
              .eq('id', created.id);
        }
      } catch (_) {
        // Soft-fail: creation should not break if inspection logging fails
      }

      return created;
    } catch (e) {
      return null;
    }
  }

  /// Get all fish products
  static Future<List<FishProduct>> getAllFishProducts() async {
    try {
      final response = await _supabase
          .from('fish_products')
          .select('''
            *,
            orders!fish_product_id(
              qr_code
            )
          ''')
          .order('created_at', ascending: false);

      return (response as List)
          .map((json) => FishProduct.fromJson(_extractQRCodeFromOrder(json)))
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// Get fish products by inspector
  static Future<List<FishProduct>> getFishProductsByInspector(
    String inspectorId,
  ) async {
    try {
      final response = await _supabase
          .from('fish_products')
          .select('''
            *,
            orders!fish_product_id(
              qr_code
            )
          ''')
          .eq('inspector_id', inspectorId)
          .order('created_at', ascending: false);

      return (response as List)
          .map((json) => FishProduct.fromJson(_extractQRCodeFromOrder(json)))
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// Get fish product by ID
  static Future<FishProduct?> getFishProductById(String id) async {
    try {
      final response =
          await _supabase
              .from('fish_products')
              .select('''
                *,
                orders!fish_product_id(
                  qr_code
                )
              ''')
              .eq('id', id)
              .maybeSingle();

      if (response == null) return null;

      return FishProduct.fromJson(_extractQRCodeFromOrder(response));
    } catch (e) {
      return null;
    }
  }

  /// Get fish product by QR code
  static Future<FishProduct?> getFishProductByQRCode(String qrCode) async {
    try {
      final response =
          await _supabase
              .from('fish_products')
              .select()
              .eq('qr_code', qrCode)
              .maybeSingle();

      if (response == null) return null;
      return FishProduct.fromJson(response);
    } catch (e) {
      return null;
    }
  }

  /// Update fish product
  static Future<bool> updateFishProduct({
    required String id,
    String? species,
    String? size,
    double? weight,
    String? vesselInfo,
    String? vesselName,
    String? vesselRegistration,
    String? status,
    File? newImageFile,
  }) async {
    try {
      String? imageUrl;

      // Upload new image if provided
      if (newImageFile != null) {
        final existingProduct = await getFishProductById(id);
        // Use existing QR code if available, otherwise generate image ID
        String identifier = existingProduct?.qrCode ?? _generateImageId();
        imageUrl = await _uploadImage(newImageFile, identifier);
        if (imageUrl == null) {
          throw Exception('Failed to upload new image');
        }
      }

      final updateData = <String, dynamic>{
        'updated_at': DateTime.now().toIso8601String(),
      };

      if (species != null) updateData['species'] = species;
      if (size != null) updateData['size'] = size;
      if (weight != null) updateData['weight'] = weight;
      if (vesselInfo != null) updateData['vessel_info'] = vesselInfo;
      if (vesselName != null) updateData['vessel_name'] = vesselName;
      if (vesselRegistration != null) {
        updateData['vessel_registration'] = vesselRegistration;
      }
      if (status != null) updateData['status'] = status;
      if (imageUrl != null) updateData['image_url'] = imageUrl;

      await _supabase.from('fish_products').update(updateData).eq('id', id);

      // If status was updated, append an inspection entry
      if (status != null) {
        try {
          // Fetch product to attribute inspector info
          final product = await getFishProductById(id);
          await _supabase.from('inspections').insert({
            'fish_product_id': id,
            'inspector_id': product?.inspectorId,
            'inspector_name': product?.inspectorName,
            'status': status,
            'notes': vesselInfo,
          });
        } catch (_) {
          // ignore logging errors
        }
      }

      return true;
    } catch (e) {
      return false;
    }
  }

  /// Delete fish product
  static Future<bool> deleteFishProduct(String id) async {
    try {
      // Get the product to delete associated image
      final product = await getFishProductById(id);
      if (product?.imageUrl != null) {
        await _deleteImage(product!.imageUrl!);
      }

      await _supabase.from('fish_products').delete().eq('id', id);

      return true;
    } catch (e) {
      return false;
    }
  }

  /// Search fish products
  static Future<List<FishProduct>> searchFishProducts(String query) async {
    try {
      final response = await _supabase
          .from('fish_products')
          .select('''
            *,
            orders!fish_product_id(
              qr_code
            )
          ''')
          .or(
            'species.ilike.%$query%,vessel_name.ilike.%$query%,inspector_name.ilike.%$query%',
          )
          .order('created_at', ascending: false);

      return (response as List)
          .map((json) => FishProduct.fromJson(_extractQRCodeFromOrder(json)))
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// Get fish products by status
  static Future<List<FishProduct>> getFishProductsByStatus(
    String status,
  ) async {
    try {
      final response = await _supabase
          .from('fish_products')
          .select('''
            *,
            orders!fish_product_id(
              qr_code
            )
          ''')
          .eq('status', status)
          .order('created_at', ascending: false);

      return (response as List)
          .map((json) => FishProduct.fromJson(_extractQRCodeFromOrder(json)))
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// Get fish products by species
  static Future<List<FishProduct>> getFishProductsBySpecies(
    String species,
  ) async {
    try {
      final response = await _supabase
          .from('fish_products')
          .select('''
            *,
            orders!fish_product_id(
              qr_code
            )
          ''')
          .eq('species', species)
          .order('created_at', ascending: false);

      return (response as List)
          .map((json) => FishProduct.fromJson(_extractQRCodeFromOrder(json)))
          .toList();
    } catch (e) {
      return [];
    }
  }

  // ===============================
  // üì∏ Image Upload/Storage
  // ===============================

  /// Upload image to Supabase Storage
  static Future<String?> _uploadImage(File imageFile, String imageId) async {
    try {
      final fileName =
          '${imageId}_${DateTime.now().millisecondsSinceEpoch}.jpg';
      final filePath = 'inspections/$fileName';

      final bytes = await imageFile.readAsBytes();

      await _supabase.storage
          .from(_bucketName)
          .uploadBinary(
            filePath,
            bytes,
            fileOptions: const FileOptions(contentType: 'image/jpeg'),
          );

      final imageUrl = _supabase.storage
          .from(_bucketName)
          .getPublicUrl(filePath);

      return imageUrl;
    } catch (e) {
      return null;
    }
  }

  /// Upload image bytes (for Web) to Supabase Storage
  static Future<String?> _uploadImageBytes(
    Uint8List bytes,
    String imageId,
  ) async {
    try {
      final fileName =
          '${imageId}_${DateTime.now().millisecondsSinceEpoch}.jpg';
      final filePath = 'inspections/$fileName';

      await _supabase.storage
          .from(_bucketName)
          .uploadBinary(
            filePath,
            bytes,
            fileOptions: const FileOptions(contentType: 'image/jpeg'),
          );

      final imageUrl = _supabase.storage
          .from(_bucketName)
          .getPublicUrl(filePath);

      return imageUrl;
    } catch (e) {
      return null;
    }
  }

  /// Delete image from Supabase Storage
  static Future<bool> _deleteImage(String imageUrl) async {
    try {
      // Extract file path from URL
      final uri = Uri.parse(imageUrl);
      final pathSegments = uri.pathSegments;
      final filePath = pathSegments
          .sublist(pathSegments.indexOf(_bucketName) + 1)
          .join('/');

      await _supabase.storage.from(_bucketName).remove([filePath]);

      return true;
    } catch (e) {
      return false;
    }
  }

  // ===============================
  // üîç QR Code Generation
  // ===============================

  /// Generate unique image identifier (not a QR code)
  static String _generateImageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final random = _uuid.v4().substring(0, 8);
    return 'IMG_${timestamp}_$random';
  }

  /// Extract QR code from related order and create modified JSON
  static Map<String, dynamic> _extractQRCodeFromOrder(
    Map<String, dynamic> json,
  ) {
    final orders = json['orders'] as List?;
    String? qrCode = json['qr_code'];

    if (orders != null && orders.isNotEmpty) {
      final order = orders.first as Map<String, dynamic>;
      qrCode = order['qr_code'] as String?;
    }

    // Create a modified JSON with the QR code from order
    final modifiedJson = Map<String, dynamic>.from(json);
    modifiedJson['qr_code'] = qrCode;

    return modifiedJson;
  }

  // ===============================
  // üìä Analytics & Statistics
  // ===============================

  /// Get fish product statistics
  static Future<Map<String, dynamic>> getFishProductStats() async {
    try {
      final response = await _supabase
          .from('fish_products')
          .select('status, species, created_at');

      final products =
          (response as List)
              .map((json) => Map<String, dynamic>.from(json as Map))
              .toList();

      final stats = <String, dynamic>{
        'total_products': products.length,
        'pending': products.where((p) => p['status'] == 'pending').length,
        'approved': products.where((p) => p['status'] == 'approved').length,
        'rejected': products.where((p) => p['status'] == 'rejected').length,
        'cleared': products.where((p) => p['status'] == 'cleared').length,
        'species_count': <String, int>{},
        'today_count': 0,
      };

      // Count by species
      for (final product in products) {
        final species = product['species'] as String;
        stats['species_count'][species] =
            (stats['species_count'][species] ?? 0) + 1;
      }

      // Count today's products
      final today = DateTime.now();
      final todayStart = DateTime(today.year, today.month, today.day);
      stats['today_count'] =
          products.where((p) {
            final createdAt = DateTime.parse(p['created_at'] as String);
            return createdAt.isAfter(todayStart);
          }).length;

      return stats;
    } catch (e) {
      return {
        'total_products': 0,
        'pending': 0,
        'approved': 0,
        'rejected': 0,
        'cleared': 0,
        'species_count': <String, int>{},
        'today_count': 0,
      };
    }
  }
}
